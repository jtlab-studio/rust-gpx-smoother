/// Improved Smart Spike Removal - Fixed thresholds based on 56-route analysis
/// Key insight: Raw elevation ratio > 1.5x official is the strongest predictor

use crate::custom_smoother::{ElevationData, create_custom_distbased_adaptive};

#[derive(Debug, Clone)]
pub struct GpsQualityMetrics {
    pub raw_elevation_gain: f64,
    pub distance_km: f64,
    pub raw_ratio: f64,
    pub elevation_noise_ratio: f64,
    pub spike_count: usize,
    pub time_variance: f64,
    pub terrain_type: String,
    pub needs_spike_removal: bool,
    pub quality_score: f64,
    pub decision_reason: String,
}

impl GpsQualityMetrics {
    pub fn analyze_gps_quality(
        elevations: &[f64], 
        distances: &[f64], 
        timestamps: Option<&[f64]>
    ) -> Self {
        let raw_elevation_gain = calculate_raw_elevation_gain(elevations);
        let distance_km = distances.last().unwrap_or(&0.0) / 1000.0;
        let gain_per_km = if distance_km > 0.0 { raw_elevation_gain / distance_km } else { 0.0 };
        
        // Classify terrain for context
        let terrain_type = match gain_per_km {
            x if x < 15.0 => "Flat".to_string(),
            x if x < 35.0 => "Rolling".to_string(), 
            x if x < 60.0 => "Hilly".to_string(),
            _ => "Mountainous".to_string(),
        };
        
        // Calculate supporting metrics
        let elevation_noise_ratio = calculate_elevation_noise_ratio(elevations);
        let spike_count = count_gps_spikes(elevations, 3.0);
        let time_variance = if let Some(times) = timestamps {
            calculate_time_variance(times)
        } else {
            0.0
        };
        
        // IMPROVED DECISION LOGIC - Based on analysis findings
        let (needs_spike_removal, quality_score, decision_reason) = Self::make_improved_decision(
            raw_elevation_gain,
            gain_per_km,
            &terrain_type,
            elevation_noise_ratio,
            spike_count,
            time_variance
        );
        
        // Calculate raw ratio for reporting (we don't have official here, so estimate)
        let estimated_reasonable_gain = match terrain_type.as_str() {
            "Flat" => distance_km * 8.0,      // ~8m/km for flat
            "Rolling" => distance_km * 25.0,  // ~25m/km for rolling  
            "Hilly" => distance_km * 45.0,    // ~45m/km for hilly
            _ => distance_km * 70.0,          // ~70m/km for mountainous
        };
        
        let raw_ratio = if estimated_reasonable_gain > 0.0 { 
            raw_elevation_gain / estimated_reasonable_gain 
        } else { 
            1.0 
        };
        
        GpsQualityMetrics {
            raw_elevation_gain,
            distance_km,
            raw_ratio,
            elevation_noise_ratio,
            spike_count,
            time_variance,
            terrain_type,
            needs_spike_removal,
            quality_score,
            decision_reason,
        }
    }
    
    fn make_improved_decision(
        raw_gain: f64,
        gain_per_km: f64,
        terrain_type: &str,
        noise_ratio: f64,
        spike_count: usize,
        time_variance: f64
    ) -> (bool, f64, String) {
        
        // PRIMARY INDICATOR: Excessive raw elevation gain (most reliable)
        let excessive_gain_score = match terrain_type {
            "Flat" => {
                // Flat routes should have <15m/km, anything >25m/km is suspicious
                if gain_per_km > 25.0 { 2.0 }
                else if gain_per_km > 15.0 { 1.0 }
                else { 0.0 }
            },
            "Rolling" => {
                // Rolling routes should have 15-35m/km, anything >50m/km is suspicious  
                if gain_per_km > 50.0 { 2.0 }
                else if gain_per_km > 35.0 { 1.0 }
                else { 0.0 }
            },
            "Hilly" => {
                // Hilly routes should have 35-60m/km, anything >80m/km is suspicious
                if gain_per_km > 80.0 { 2.0 }
                else if gain_per_km > 60.0 { 1.0 }  
                else { 0.0 }
            },
            _ => {
                // Mountainous routes can handle more, >120m/km is suspicious
                if gain_per_km > 120.0 { 2.0 }
                else if gain_per_km > 90.0 { 1.0 }
                else { 0.0 }
            }
        };
        
        // SECONDARY INDICATORS
        let noise_score = if noise_ratio > 0.7 { 1.0 } else if noise_ratio > 0.5 { 0.5 } else { 0.0 };
        let spike_score = if spike_count > (gain_per_km / 10.0) as usize { 1.0 } else { 0.0 };
        let timing_score = if time_variance > 30.0 { 0.5 } else { 0.0 };
        
        // CALCULATE OVERALL SCORE
        let total_score = excessive_gain_score + (noise_score * 0.3) + (spike_score * 0.2) + (timing_score * 0.1);
        
        // DECISION LOGIC - More aggressive than before
        let (needs_spike_removal, reason) = if excessive_gain_score >= 2.0 {
            (true, format!("Excessive gain: {:.1}m/km for {} terrain", gain_per_km, terrain_type))
        } else if excessive_gain_score >= 1.0 && (noise_score > 0.0 || spike_score > 0.0) {
            (true, format!("High gain ({:.1}m/km) + noise/spikes for {} terrain", gain_per_km, terrain_type))
        } else if total_score > 1.2 {
            (true, format!("Multiple quality issues (score: {:.1})", total_score))
        } else {
            (false, format!("Good GPS quality (score: {:.1})", total_score))
        };
        
        println!("ðŸ” GPS Quality Analysis:");
        println!("  Terrain: {} ({:.1}m/km)", terrain_type, gain_per_km);
        println!("  Scores: Excessive={:.1}, Noise={:.1}, Spikes={:.1}, Timing={:.1}", 
                 excessive_gain_score, noise_score, spike_score, timing_score);
        println!("  Decision: {} - {}", if needs_spike_removal { "APPLY SPIKES" } else { "SKIP SPIKES" }, reason);
        
        (needs_spike_removal, total_score, reason)
    }
}

fn calculate_raw_elevation_gain(elevations: &[f64]) -> f64 {
    elevations.windows(2)
        .map(|w| if w[1] > w[0] { w[1] - w[0] } else { 0.0 })
        .sum()
}

fn calculate_elevation_noise_ratio(elevations: &[f64]) -> f64 {
    if elevations.len() < 20 {
        return 0.0;
    }
    
    // Calculate 10-point moving average to identify trend
    let window_size = (elevations.len() / 10).max(5).min(15);
    let mut smoothed = vec![];
    
    for i in 0..elevations.len() {
        let start = if i >= window_size/2 { i - window_size/2 } else { 0 };
        let end = (i + window_size/2 + 1).min(elevations.len());
        let avg = elevations[start..end].iter().sum::<f64>() / (end - start) as f64;
        smoothed.push(avg);
    }
    
    // Calculate total variation vs trend variation
    let total_variation: f64 = elevations.windows(2)
        .map(|w| (w[1] - w[0]).abs())
        .sum();
    
    let trend_variation: f64 = smoothed.windows(2)
        .map(|w| (w[1] - w[0]).abs())
        .sum();
    
    if total_variation > 0.0 {
        (total_variation - trend_variation) / total_variation
    } else {
        0.0
    }
}

fn count_gps_spikes(elevations: &[f64], threshold_m: f64) -> usize {
    let mut spike_count = 0;
    
    // Use adaptive threshold based on elevation range
    let elevation_range = elevations.iter().fold(0.0f64, |acc, &x| acc.max(x)) - 
                         elevations.iter().fold(f64::INFINITY, |acc, &x| acc.min(x));
    let adaptive_threshold = threshold_m.max(elevation_range * 0.002); // 0.2% of range minimum
    
    for i in 1..elevations.len() - 1 {
        let prev = elevations[i - 1];
        let curr = elevations[i];
        let next = elevations[i + 1];
        
        let up_change = curr - prev;
        let down_change = next - curr;
        
        // Enhanced spike detection
        if up_change.abs() > adaptive_threshold && 
           down_change.abs() > adaptive_threshold && 
           up_change.signum() != down_change.signum() &&
           up_change.abs() + down_change.abs() > adaptive_threshold * 1.5 {
            spike_count += 1;
        }
    }
    
    spike_count
}

fn calculate_time_variance(timestamps: &[f64]) -> f64 {
    if timestamps.len() < 10 {
        return 0.0;
    }
    
    let intervals: Vec<f64> = timestamps.windows(2)
        .map(|w| w[1] - w[0])
        .filter(|&interval| interval > 0.0 && interval < 3600.0)
        .collect();
    
    if intervals.is_empty() {
        return 0.0;
    }
    
    let mean = intervals.iter().sum::<f64>() / intervals.len() as f64;
    let variance = intervals.iter()
        .map(|&x| (x - mean).powi(2))
        .sum::<f64>() / intervals.len() as f64;
    
    variance.sqrt()
}

/// Smart processing with improved decision making
pub fn smart_spike_distbased(
    elevations: Vec<f64>, 
    distances: Vec<f64>,
    timestamps: Option<Vec<f64>>
) -> f64 {
    println!("ðŸ” Analyzing GPS data quality with IMPROVED thresholds...");
    
    let quality_metrics = GpsQualityMetrics::analyze_gps_quality(
        &elevations, 
        &distances, 
        timestamps.as_deref()
    );
    
    if quality_metrics.needs_spike_removal {
        println!("ðŸ”§ Applying IMPROVED Smart Spike â†’ DistBased");
        println!("   Reason: {}", quality_metrics.decision_reason);
        
        // Apply enhanced spike removal with terrain-aware parameters
        let spike_removed = terrain_aware_spike_removal(&elevations, &distances, &quality_metrics);
        
        // Apply DistBased processing
        let distbased_result = create_custom_distbased_adaptive(spike_removed, distances);
        distbased_result.get_total_elevation_gain()
    } else {
        println!("ðŸŽ¯ Applying DistBased only (GPS quality sufficient)");
        println!("   Reason: {}", quality_metrics.decision_reason);
        
        // Skip spike removal, apply DistBased directly
        let distbased_result = create_custom_distbased_adaptive(elevations, distances);
        distbased_result.get_total_elevation_gain()
    }
}

/// Terrain-aware spike removal with adaptive parameters
fn terrain_aware_spike_removal(
    elevations: &[f64], 
    _distances: &[f64], 
    quality_metrics: &GpsQualityMetrics
) -> Vec<f64> {
    if elevations.len() < 3 {
        return elevations.to_vec();
    }
    
    // Adapt threshold based on terrain and quality score
    let base_threshold = match quality_metrics.terrain_type.as_str() {
        "Flat" => 2.0,        // More sensitive for flat terrain
        "Rolling" => 3.0,     // Standard sensitivity
        "Hilly" => 4.0,       // Less sensitive for hilly terrain  
        _ => 5.0,             // Least sensitive for mountains
    };
    
    // Further adapt based on quality score
    let threshold_m = if quality_metrics.quality_score > 2.0 {
        base_threshold * 0.7  // More aggressive for very poor GPS
    } else if quality_metrics.quality_score > 1.5 {
        base_threshold        // Standard for poor GPS
    } else {
        base_threshold * 1.2  // Conservative for borderline cases
    };
    
    let original_gain = calculate_raw_elevation_gain(elevations);
    let mut result = elevations.to_vec();
    let mut spikes_removed = 0;
    
    // Multi-pass spike removal
    for _pass in 0..2 {  // Two passes for stubborn spikes
        let mut pass_spikes = 0;
        
        for i in 1..result.len() - 1 {
            let prev = result[i - 1];
            let curr = result[i];
            let next = result[i + 1];
            
            let up_change = curr - prev;
            let down_change = next - curr;
            
            // Enhanced spike detection with context awareness
            if up_change.abs() > threshold_m && 
               down_change.abs() > threshold_m && 
               up_change.signum() != down_change.signum() {
                
                // Additional check: spike should be significant relative to neighbors
                let context_range = [
                    if i > 1 { result[i-2] } else { prev },
                    prev,
                    next,
                    if i < result.len()-2 { result[i+2] } else { next }
                ];
                let context_avg = context_range.iter().sum::<f64>() / context_range.len() as f64;
                
                if (curr - context_avg).abs() > threshold_m * 0.7 {
                    // Use elevation-weighted interpolation
                    let weight_prev = 1.0 / (1.0 + up_change.abs());
                    let weight_next = 1.0 / (1.0 + down_change.abs());
                    let total_weight = weight_prev + weight_next;
                    
                    result[i] = (prev * weight_prev + next * weight_next) / total_weight;
                    pass_spikes += 1;
                }
            }
        }
        
        spikes_removed += pass_spikes;
        if pass_spikes == 0 { break; } // No more spikes found
    }
    
    let final_gain = calculate_raw_elevation_gain(&result);
    
    if spikes_removed > 0 {
        println!("ðŸ”§ Terrain-aware spike removal ({}):", quality_metrics.terrain_type);
        println!("   {} spikes removed with {:.1}m threshold", spikes_removed, threshold_m);
        println!("   {:.1}m â†’ {:.1}m ({:+.1}% change)", 
                 original_gain, final_gain, 
                 ((final_gain - original_gain) / original_gain) * 100.0);
    }
    
    result
}

/// Convenience function for backward compatibility
pub fn simple_spike_removal_only(elevations: &[f64], distances: &[f64]) -> Vec<f64> {
    // Use quality analysis to determine if spikes should be removed
    let quality_metrics = GpsQualityMetrics::analyze_gps_quality(elevations, distances, None);
    
    if quality_metrics.needs_spike_removal {
        terrain_aware_spike_removal(elevations, distances, &quality_metrics)
    } else {
        elevations.to_vec()  // Return unchanged if quality is good
    }
}
