/// EMERGENCY FIX - Simplified Smart Spike Removal
/// The previous version was too conservative - this uses DIRECT raw ratio analysis

use crate::custom_smoother::{ElevationData, create_custom_distbased_adaptive};

#[derive(Debug, Clone)]
pub struct GpsQualityMetrics {
    pub raw_elevation_gain: f64,
    pub distance_km: f64,
    pub raw_ratio: f64,
    pub terrain_type: String,
    pub needs_spike_removal: bool,
    pub quality_score: f64,
    pub decision_reason: String,
}

impl GpsQualityMetrics {
    pub fn analyze_gps_quality(
        elevations: &[f64], 
        distances: &[f64], 
        timestamps: Option<&[f64]>
    ) -> Self {
        let raw_elevation_gain = calculate_raw_elevation_gain(elevations);
        let distance_km = distances.last().unwrap_or(&0.0) / 1000.0;
        let gain_per_km = if distance_km > 0.0 { raw_elevation_gain / distance_km } else { 0.0 };
        
        // Classify terrain
        let terrain_type = match gain_per_km {
            x if x < 15.0 => "Flat".to_string(),
            x if x < 35.0 => "Rolling".to_string(), 
            x if x < 60.0 => "Hilly".to_string(),
            _ => "Mountainous".to_string(),
        };
        
        // SIMPLIFIED DECISION: Based purely on excessive elevation gain
        let expected_reasonable_gain = match terrain_type.as_str() {
            "Flat" => distance_km * 10.0,      // 10m/km max for flat
            "Rolling" => distance_km * 30.0,   // 30m/km max for rolling  
            "Hilly" => distance_km * 55.0,     // 55m/km max for hilly
            _ => distance_km * 80.0,           // 80m/km max for mountainous
        };
        
        let raw_ratio = if expected_reasonable_gain > 0.0 { 
            raw_elevation_gain / expected_reasonable_gain 
        } else { 
            1.0 
        };
        
        // AGGRESSIVE DECISION MAKING
        let (needs_spike_removal, quality_score, decision_reason) = if raw_ratio > 2.0 {
            (true, raw_ratio, format!("Very excessive gain: {:.1}x expected for {} terrain", raw_ratio, terrain_type))
        } else if raw_ratio > 1.4 {
            (true, raw_ratio, format!("Excessive gain: {:.1}x expected for {} terrain", raw_ratio, terrain_type))
        } else if gain_per_km > 100.0 && terrain_type != "Mountainous" {
            (true, 1.5, format!("Extreme gain rate: {:.1}m/km for {} terrain", gain_per_km, terrain_type))
        } else {
            (false, raw_ratio, format!("Reasonable gain: {:.1}x expected ({:.1}m/km)", raw_ratio, gain_per_km))
        };
        
        println!("🔍 SIMPLIFIED GPS Analysis:");
        println!("  Terrain: {} ({:.1}m/km)", terrain_type, gain_per_km);
        println!("  Raw: {:.0}m, Expected: {:.0}m, Ratio: {:.1}x", raw_elevation_gain, expected_reasonable_gain, raw_ratio);
        println!("  Decision: {} - {}", if needs_spike_removal { "APPLY SPIKES" } else { "SKIP SPIKES" }, decision_reason);
        
        GpsQualityMetrics {
            raw_elevation_gain,
            distance_km,
            raw_ratio,
            terrain_type,
            needs_spike_removal,
            quality_score,
            decision_reason,
        }
    }
}

fn calculate_raw_elevation_gain(elevations: &[f64]) -> f64 {
    elevations.windows(2)
        .map(|w| if w[1] > w[0] { w[1] - w[0] } else { 0.0 })
        .sum()
}

/// Simplified smart processing - direct raw ratio analysis
pub fn smart_spike_distbased(
    elevations: Vec<f64>, 
    distances: Vec<f64>,
    timestamps: Option<Vec<f64>>
) -> f64 {
    println!("🔍 Running EMERGENCY FIXED Smart Spike Analysis...");
    
    let quality_metrics = GpsQualityMetrics::analyze_gps_quality(
        &elevations, 
        &distances, 
        timestamps.as_deref()
    );
    
    if quality_metrics.needs_spike_removal {
        println!("🔧 Applying EMERGENCY Smart Spike → DistBased");
        println!("   Reason: {}", quality_metrics.decision_reason);
        
        // Apply simple but effective spike removal
        let spike_removed = simple_but_effective_spike_removal(&elevations);
        
        // Apply DistBased processing
        let distbased_result = create_custom_distbased_adaptive(spike_removed, distances);
        distbased_result.get_total_elevation_gain()
    } else {
        println!("🎯 Applying DistBased only");
        println!("   Reason: {}", quality_metrics.decision_reason);
        
        // Skip spike removal, apply DistBased directly
        let distbased_result = create_custom_distbased_adaptive(elevations, distances);
        distbased_result.get_total_elevation_gain()
    }
}

/// Simple but effective spike removal - proven approach
fn simple_but_effective_spike_removal(elevations: &[f64]) -> Vec<f64> {
    if elevations.len() < 3 {
        return elevations.to_vec();
    }
    
    let original_gain = calculate_raw_elevation_gain(elevations);
    let mut result = elevations.to_vec();
    let mut spikes_removed = 0;
    
    // Use proven 3m threshold with 2 passes
    let threshold_m = 3.0;
    
    for _pass in 0..2 {
        let mut pass_spikes = 0;
        
        for i in 1..result.len() - 1 {
            let prev = result[i - 1];
            let curr = result[i];
            let next = result[i + 1];
            
            let up_change = curr - prev;
            let down_change = next - curr;
            
            // Simple spike detection: large opposite changes
            if up_change.abs() > threshold_m && 
               down_change.abs() > threshold_m && 
               up_change.signum() != down_change.signum() {
                
                // Simple interpolation
                result[i] = (prev + next) / 2.0;
                pass_spikes += 1;
            }
        }
        
        spikes_removed += pass_spikes;
        if pass_spikes == 0 { break; }
    }
    
    let final_gain = calculate_raw_elevation_gain(&result);
    
    if spikes_removed > 0 {
        println!("🔧 Emergency spike removal: {} spikes removed", spikes_removed);
        println!("   {:.1}m → {:.1}m ({:+.1}% change)", 
                 original_gain, final_gain, 
                 ((final_gain - original_gain) / original_gain) * 100.0);
    }
    
    result
}

/// Simplified version for backward compatibility
pub fn simple_spike_removal_only(elevations: &[f64], distances: &[f64]) -> Vec<f64> {
    let quality_metrics = GpsQualityMetrics::analyze_gps_quality(elevations, distances, None);
    
    if quality_metrics.needs_spike_removal {
        simple_but_effective_spike_removal(elevations)
    } else {
        elevations.to_vec()
    }
}
