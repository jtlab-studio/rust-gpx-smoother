/// ULTRA AGGRESSIVE Smart Spike Removal - Final fix to catch all problem routes
/// Analysis shows we need to be MUCH more aggressive with thresholds

use crate::custom_smoother::{ElevationData, create_custom_distbased_adaptive};

#[derive(Debug, Clone)]
pub struct GpsQualityMetrics {
    pub raw_elevation_gain: f64,
    pub distance_km: f64,
    pub raw_ratio: f64,
    pub terrain_type: String,
    pub needs_spike_removal: bool,
    pub quality_score: f64,
    pub decision_reason: String,
}

impl GpsQualityMetrics {
    pub fn analyze_gps_quality(
        elevations: &[f64], 
        distances: &[f64], 
        timestamps: Option<&[f64]>
    ) -> Self {
        let raw_elevation_gain = calculate_raw_elevation_gain(elevations);
        let distance_km = distances.last().unwrap_or(&0.0) / 1000.0;
        let gain_per_km = if distance_km > 0.0 { raw_elevation_gain / distance_km } else { 0.0 };
        
        // Classify terrain
        let terrain_type = match gain_per_km {
            x if x < 15.0 => "Flat".to_string(),
            x if x < 35.0 => "Rolling".to_string(), 
            x if x < 60.0 => "Hilly".to_string(),
            _ => "Mountainous".to_string(),
        };
        
        // ULTRA AGGRESSIVE THRESHOLDS - catch everything suspicious
        let expected_reasonable_gain = match terrain_type.as_str() {
            "Flat" => distance_km * 12.0,      // 12m/km max for flat (was 10)
            "Rolling" => distance_km * 35.0,   // 35m/km max for rolling (was 30)
            "Hilly" => distance_km * 65.0,     // 65m/km max for hilly (was 55)  
            _ => distance_km * 90.0,           // 90m/km max for mountainous (was 80)
        };
        
        let raw_ratio = if expected_reasonable_gain > 0.0 { 
            raw_elevation_gain / expected_reasonable_gain 
        } else { 
            1.0 
        };
        
        // ULTRA AGGRESSIVE DECISION MAKING - catch almost everything
        let (needs_spike_removal, quality_score, decision_reason) = if raw_ratio > 1.8 {
            (true, raw_ratio, format!("Very excessive gain: {:.1}x expected for {} terrain", raw_ratio, terrain_type))
        } else if raw_ratio > 1.2 {  // MUCH lower threshold!
            (true, raw_ratio, format!("Excessive gain: {:.1}x expected for {} terrain", raw_ratio, terrain_type))
        } else if gain_per_km > 50.0 && terrain_type == "Flat" {
            (true, 1.5, format!("Extreme gain for flat: {:.1}m/km", gain_per_km))
        } else if gain_per_km > 80.0 && terrain_type == "Rolling" {
            (true, 1.3, format!("Extreme gain for rolling: {:.1}m/km", gain_per_km))
        } else if gain_per_km > 120.0 && terrain_type == "Hilly" {
            (true, 1.2, format!("Extreme gain for hilly: {:.1}m/km", gain_per_km))
        } else {
            (false, raw_ratio, format!("Reasonable gain: {:.1}x expected ({:.1}m/km)", raw_ratio, gain_per_km))
        };
        
        println!("ðŸ”¥ ULTRA AGGRESSIVE GPS Analysis:");
        println!("  Terrain: {} ({:.1}m/km)", terrain_type, gain_per_km);
        println!("  Raw: {:.0}m, Expected: {:.0}m, Ratio: {:.1}x", raw_elevation_gain, expected_reasonable_gain, raw_ratio);
        println!("  Decision: {} - {}", if needs_spike_removal { "ðŸ”¥ APPLY SPIKES" } else { "SKIP SPIKES" }, decision_reason);
        
        GpsQualityMetrics {
            raw_elevation_gain,
            distance_km,
            raw_ratio,
            terrain_type,
            needs_spike_removal,
            quality_score,
            decision_reason,
        }
    }
}

fn calculate_raw_elevation_gain(elevations: &[f64]) -> f64 {
    elevations.windows(2)
        .map(|w| if w[1] > w[0] { w[1] - w[0] } else { 0.0 })
        .sum()
}

/// Ultra aggressive smart processing - catch all problem routes
pub fn smart_spike_distbased(
    elevations: Vec<f64>, 
    distances: Vec<f64>,
    timestamps: Option<Vec<f64>>
) -> f64 {
    println!("ðŸ”¥ Running ULTRA AGGRESSIVE Smart Spike Analysis...");
    
    let quality_metrics = GpsQualityMetrics::analyze_gps_quality(
        &elevations, 
        &distances, 
        timestamps.as_deref()
    );
    
    if quality_metrics.needs_spike_removal {
        println!("ðŸ”¥ Applying ULTRA AGGRESSIVE Smart Spike â†’ DistBased");
        println!("   Reason: {}", quality_metrics.decision_reason);
        
        // Apply aggressive spike removal
        let spike_removed = ultra_aggressive_spike_removal(&elevations, &quality_metrics);
        
        // Apply DistBased processing
        let distbased_result = create_custom_distbased_adaptive(spike_removed, distances);
        distbased_result.get_total_elevation_gain()
    } else {
        println!("ðŸŽ¯ Applying DistBased only");
        println!("   Reason: {}", quality_metrics.decision_reason);
        
        // Skip spike removal, apply DistBased directly
        let distbased_result = create_custom_distbased_adaptive(elevations, distances);
        distbased_result.get_total_elevation_gain()
    }
}

/// Ultra aggressive spike removal - multiple passes with adaptive thresholds
fn ultra_aggressive_spike_removal(elevations: &[f64], quality_metrics: &GpsQualityMetrics) -> Vec<f64> {
    if elevations.len() < 3 {
        return elevations.to_vec();
    }
    
    let original_gain = calculate_raw_elevation_gain(elevations);
    let mut result = elevations.to_vec();
    let mut total_spikes_removed = 0;
    
    // MULTIPLE AGGRESSIVE PASSES with decreasing thresholds
    let thresholds = match quality_metrics.terrain_type.as_str() {
        "Flat" => vec![4.0, 3.0, 2.0],        // Very aggressive for flat
        "Rolling" => vec![5.0, 4.0, 3.0],     // Aggressive for rolling
        "Hilly" => vec![6.0, 5.0, 4.0],       // Moderate for hilly
        _ => vec![8.0, 6.0, 5.0],             // Conservative for mountains
    };
    
    for (pass, &threshold_m) in thresholds.iter().enumerate() {
        let mut pass_spikes = 0;
        
        for i in 1..result.len() - 1 {
            let prev = result[i - 1];
            let curr = result[i];
            let next = result[i + 1];
            
            let up_change = curr - prev;
            let down_change = next - curr;
            
            // ULTRA AGGRESSIVE spike detection
            if up_change.abs() > threshold_m && 
               down_change.abs() > threshold_m && 
               up_change.signum() != down_change.signum() {
                
                // Advanced interpolation with context
                let context_start = if i > 2 { i - 2 } else { 0 };
                let context_end = if i < result.len() - 3 { i + 3 } else { result.len() };
                let context_avg = result[context_start..context_end].iter().sum::<f64>() 
                                / (context_end - context_start) as f64;
                
                // Weight interpolation towards context average for extreme spikes
                let spike_magnitude = (curr - context_avg).abs();
                if spike_magnitude > threshold_m * 0.5 {
                    let weight_context = (spike_magnitude / (threshold_m * 2.0)).min(0.3);
                    let weight_neighbors = 1.0 - weight_context;
                    
                    let neighbor_avg = (prev + next) / 2.0;
                    result[i] = neighbor_avg * weight_neighbors + context_avg * weight_context;
                    pass_spikes += 1;
                }
            }
        }
        
        total_spikes_removed += pass_spikes;
        println!("ðŸ”¥ Pass {} ({:.1}m threshold): {} spikes removed", pass + 1, threshold_m, pass_spikes);
        
        if pass_spikes == 0 { break; } // No more spikes found
    }
    
    // ADDITIONAL SMOOTHING for very noisy data
    if quality_metrics.raw_ratio > 2.0 {
        println!("ðŸ”¥ Applying additional smoothing for very noisy data (ratio: {:.1}x)", quality_metrics.raw_ratio);
        
        // 3-point moving average for extreme cases
        let mut smoothed = result.clone();
        for i in 1..result.len() - 1 {
            smoothed[i] = (result[i - 1] + result[i] + result[i + 1]) / 3.0;
        }
        
        // Blend original and smoothed based on noise level
        let blend_factor = ((quality_metrics.raw_ratio - 2.0) / 2.0).min(0.3);
        for i in 0..result.len() {
            result[i] = result[i] * (1.0 - blend_factor) + smoothed[i] * blend_factor;
        }
    }
    
    let final_gain = calculate_raw_elevation_gain(&result);
    
    if total_spikes_removed > 0 {
        println!("ðŸ”¥ ULTRA AGGRESSIVE spike removal complete:");
        println!("   {} total spikes removed from {} terrain", total_spikes_removed, quality_metrics.terrain_type);
        println!("   {:.1}m â†’ {:.1}m ({:+.1}% change)", 
                 original_gain, final_gain, 
                 ((final_gain - original_gain) / original_gain) * 100.0);
    }
    
    result
}

/// Ultra aggressive version for backward compatibility
pub fn simple_spike_removal_only(elevations: &[f64], distances: &[f64]) -> Vec<f64> {
    let quality_metrics = GpsQualityMetrics::analyze_gps_quality(elevations, distances, None);
    
    if quality_metrics.needs_spike_removal {
        ultra_aggressive_spike_removal(elevations, &quality_metrics)
    } else {
        elevations.to_vec()
    }
}
